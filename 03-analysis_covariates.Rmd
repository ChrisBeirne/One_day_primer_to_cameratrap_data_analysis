# Analysis covariates {#covariates}

Once we have created the building blocks for our data analysis dataframes, we must bring in the variables which will be used in the modelling steps. It is important to not that there are millions of ways to add covariates - both in terms of how you do it, and where you derrive the data from. The covariates you use will dpeend on the questions you have, and the context of your survey. The examples provided here are not comprehensive and serve only as a guide!

**load the required packages**

```{r, echo=T, eval=F}
library(kableExtra);library(dplyr); library(sf); library(MODISTools); library(lubridate); library(corrplot); library(traitdata); library(terra); library(osmdata); library(elevatr)
```

```{r, echo=F, include=F}
library(kableExtra);library(dplyr); library(sf); library(MODISTools); library(lubridate); library(corrplot); library(traitdata); library(terra); library(osmdata); library(elevatr); library(rgee)
```

We can simplify the covariate options we have available into two distinct categories:

**- Species traits**
 
The traits are species-level covariates which we think are important in structuring their responces to other covariates, such as human modification.  

```{r}
# Start by reading in your species list
sp_summary <- read.csv("data/processed_data/AlgarRestorationProject_species_list.csv", header=T)
```
 
 
**- Location-level covariates**

Location-level covariates are characteristics of the camera locations which are either fundamental to your question (such as the habitat type, degree of human modification, or distance to the nearest road), or they are things you are not directly interested in but must account for in your analyses. The way we derive and treat these variables are identical however. 

```{r}
locs <- read.csv("data/processed_data/AlgarRestorationProject_camera_locations.csv", header=T)
```


## Species traits

It is easier than ever before to add trait data to your species lists, particularly with the advent of R packages which pool multiple data sources such as the [`traitdata` database](https://github.com/RS-eco/traitdata), which to date, compiles data from 32 different sources.

Below we use this package to add trait data to the project species list:

```{r}

# This package isn't available on Cran, so we must use the remotes package
#library(remotes)
#remotes::install_github("RS-eco/traitdata", build_vignettes = T, force=T)
# Load the library
library(traitdata)
```

To pull the data for a specific database we use the following code:

```{r}
data("elton_mammals")

# To see all the options available run: 

```

To explore the full list of available datasets clikc [this link](https://opentraits.org/datasets.html).

Let's take a look at what categories we have available to us:

```{r}
 head(elton_mammals) %>% kbl() %>% scroll_box(height = "200px") %>%
  kable_paper("striped", full_width = F)
```

Lets make a new column `sp` which matches the species column in our 'sp_summary' datset. We will use this as the "key" variable to extract the trait data. 

```{r}
elton_mammals$sp <- paste0(elton_mammals$Genus,"." ,elton_mammals$Species)
```

We do not want to take all of the trait data, so lets subset to `BodyMass.Value` and the activity data `Activity.Nocturnal	Activity.Crepuscular	Activity.Diurnal`.

```{r, warning=F, message=F}
tmp <- elton_mammals[, c("sp","BodyMass.Value", "Activity.Nocturnal", "Activity.Crepuscular",	"Activity.Diurnal")]

# Lets rename the columsn to make them more usable
tmp <- tmp %>% rename(
              mass_g = BodyMass.Value,
              act_noct = Activity.Nocturnal,
              act_crep = Activity.Crepuscular,
              act_diur = Activity.Diurnal)

sp_summary <- left_join(sp_summary, tmp)
```

And then check our output:

```{r}
sp_summary %>% kbl() %>% scroll_box(height = "200px") %>%
  kable_paper("striped", full_width = F)
```

If there are any NA's, it could be for several reasons:

i) There is no trait data for that species - in this case you could either:

- leave them as NA's (excluding them from later analyses) or if you are lucky, your analysis framework might be able to accomodate missing trait data

- Give the species the mean values obtained from other species in its genus 

ii) There is a mismatch in taxonomic resolution - you are working with a subspecies that isn'r recognised. Maybe then you can use the sister-species. 

Whatever you do, remember to report it in your methods section!

Let's save our species list for a rainy day!

```{r}
write.csv(sp_summary, paste0("data/processed_data/", locs$project_id[1],"_species_list.csv"), row.names = F)
```

## Camera station covariates

It is common to have a suite of covariates which you would like to investigate the effects of in your datasets. These could take the form of habitat designations or treatment types. These may already be included with your deployment data, or you may need to derive them from a variety of remote sources. In their simplest form, these variable are time invariant (they do not change), however you may have variables which change through time as well (we discuss these at the end). In the following steps, we walk through the process of manipulating and deriving example covariates.

For the time invariant covariates, we will add them to our `locs` dataframe imported above.

### Locally collected covariates

You may have collected some data in the field when deploying or checking your camera traps, and kept that data separate from your camera trap data (e.g. vegetation assessments). Provided that the naming convention you gave to these dataframes is the same as in your camera data (e.g. the location is in a column called `placename`) - you can do a 'left_join()` to merge the two datasets.

Import a sample set of local covariates:

```{r}
local_covs <- read.csv("data/raw_data/example_covariates/example_dataframe.csv")
```

Lets take a look at the data structure:

```{r}
local_covs %>% kbl() %>% 
  kableExtra::scroll_box(height = "250px")
```

It is a dataframe where the survey locations are rows and the local covariates, in this case `line_of_sight_m`, are columns.

To add this data to our station data, we use a `left_join()` operation from the `dplyr()` package. It uses a key variable which is common in both data frames to add data from the "right-hand side" to the rows in the "left-hand side" which are not already present. Any rows present in the right-hand side which are not in the left-hand side will be skipped.

```{r, message=F, warning=F}
library(dplyr)

locs <- left_join(locs, local_covs)

```

For more examples of joins using `dplyr()` see: [https://dplyr.tidyverse.org/reference/mutate-joins.html](https://dplyr.tidyverse.org/reference/mutate-joins.html)

### Remotely collected covariates

To exploit remotely collected data sources we need to use a package to help us with spatial data.

#### Key skills: `sf` package

The most intuitive package to learn spatial operations in R is the `simple features` package (a.k.a. `sf`).
`sf`  allows you to use spatial dataframes in the style of a typical R dataframe. We use this package frequently as it allows you to rapidly change coordinate projection systems (e.g. lat/long to UTM) and rapidly perform spatial operations.

Lets convert our "normal" dataframe to an `sf` dataframe:

```{r}
locs_sf <- st_as_sf(locs,                              # We specify the dataframe 
                    coords=c("longitude", "latitude"), # The XY coordinates
                    crs=4326)                          # And the projection code
```

What does an `sf` object look like? Like a normal dataframe but with a weird header: 

```{r}
locs_sf
```

That header is important - it tells you the type of data you have (lines, points, polygons etc), and the projection information (`CRS`).

We like using `sf` as it is very easy to transform coordinates into different projections using `st_transform()`. USe the website [epsg.io](https://epsg.io/) to find the CRS codes for the projection you want - e.g. UTM 12N = 26712, then plug it into the following:

```{r, eval=T}
locs_utm <- st_transform(locs_sf, crs=26712)
```

Check the header of `locs_utm` and you should see that the CRS has changed!

Plotting `sf` is a little bit weird. If you try to plot them normally you get lots of replicated plots (one for each column) - try it:

```{r}
plot(locs_utm)
```

It can be useful as it varied the colours based on the propoerties of the column. Typically, however, we just want to plot the points themselves. We do that by wrapping the object in `st_geometry()` this just extracts the geometry of the object.

```{r}
plot(st_geometry(locs_utm))
axis(1)
axis(2)
```

We will use `st_geometry()` frequently below.

For more in depth information of `sf` functionality see: [https://r-spatial.github.io/sf/articles/sf1.html](https://r-spatial.github.io/sf/articles/sf1.html) 


### Extracting data from local rasters

Often we have raster data layers stored which we would like to link to our camera locations. We have included one such example here, a raster which reflects the depth from the soil surface to the water table - a proxy for habitat type in this study site. The layer comes from the 1m Wet Area Mapping (WAM) layer:

[White, Barry, et al. "Using the cartographic depth-to-water index to locate small streams and associated wet areas across landscapes." Canadian Water Resources Journal 37.4 (2012): 333-347.](https://www.tandfonline.com/doi/full/10.4296/cwrj2011-909)

*NOTE* the raster has been downscaled to reduce its size for this course - it is no longer at 1m resolution.

The only time we deviate from the `sf` package is to deal with rasters. Raster objects in R are processed really slowly, especially if the raster is large. So instead we use the `terra` package.

```{r}
library(terra)
# Import the example raster using the stars package
ras <- rast("data/raw_data/example_covariates/example_raster.tif")
# Covert your sf locations to the same projection as your raster then put it in terra `vect` format,
locs_terra <- locs_sf %>% 
                st_transform(crs=st_crs(ras)) %>% # change the projection to match the raster
                vect() # Turn it into a terra object

```

Lets check our layers match up!

```{r}
plot(ras) # The terra package makes nice raster plots with legends
plot(locs_terra, add=T) # Add the survey locations as black dots
```

Great! Now lets buffer our camera locations by 250 meters, and take the average depth to water for each location:

```{r}
# Buffer by 250m
locs_terra <- buffer(locs_terra,250)

# Extract the values to a temporary object - tmp 
tmp <- extract(ras, locs_terra, fun=mean)

# Make a new column in locs_sf called water_depth_m
# They are ordered the same way so no need for a fancy join
locs_sf$water_depth_m <- tmp$Depth2WatAlgar

```

Finally, lets check the distribution of our data!

```{r}
# Basic boxplot in base R
boxplot(locs_sf$water_depth_m)
```

Most locations are on the water table (lowland sites), others are above it (upload sites), and they have different vegetation characteristics in the field. 

### elevatr package

Camera studies often occur over a range of elevations - and we can quickly extract these elevations using the `elevatr` package and an `sf` dataframe.


```{r}
library(elevatr)
locs_sf <- get_elev_point(locs_sf, 
                          src="aws", #Amazon Web Service Terrain Tiles - available globally
                          z = 12)  # z specifies the zoom level, the lower the value the faster the code runs, but the coarser the elevation values are
```

The `src` option specifies the sources of the DEM data. We use `aws` Amazon Web Service Terrain Tiles - which are available globally.

The `z` option specifies the resolution of the underlying DEM, the high the value, the more detailed it is. However, it will take longer to run so do not go crazy. 

Let's plot the output:

```{r}
boxplot(locs_sf$elevation)
```

An elevation of ~ 500m was expected. Great!

If you want to download a full elevation raster for your area of interests, see the [`introduction to elevatr`](https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html)

### Open Street Maps
Open Street Map (OSM) is an incredible resource for generating covariates for camera trap studies. For example, we might be interested in the distance to the nearest rivers, roads, or trails. All of these anthropogenic features are available in OSM!

**CAREFUL** OSM data is user contributed and often incomplete and patchy. Always plot your data and never assume it is complete without checking it first. For an example fo this see `water bodies` below. 

First lets load the `osmdata` package.

```{r}
library(osmdata)
```

The types of features we can extract using the `osmdata` package are listed here: [https://wiki.openstreetmap.org/wiki/Map_features](https://wiki.openstreetmap.org/wiki/Map_features).

#### Highways

Camera trap projects are often interested in human disturbance, of which, highways are an important part.

Let's start by defining our area of interest. All `osmdata` queries begin with a bounding box defining the area of the query:  

```{r}
# First buffer our points by 10km to create an area of interest (aoi)
aoi <- st_bbox(st_buffer(locs_sf, 10000)) # Units are in meters 

```

We then use this bounding box to return all of the features which cross into it:

```{r}
highway <- opq(aoi) %>% #using the bounding box
           add_osm_feature(key="highway") %>% #extract all highway features
           osmdata_sf()  # conmvert them into simple features format

```


The data you extract is its own "class" of data made up from multiple data types:

```{r, eval=F}
str(highway)
```

Which looks very intimidating! However, the key thing is that it is made up of multiple data slices, each of which represents an `sf` dataset. Let's take a look at three of these

- $osm_points
- $osm_lines
- $osm_polygons

```{r}
par(mfrow=c(1,3))
plot(st_geometry(highway$osm_points), main="osm_points")
plot(st_geometry(highway$osm_lines), main="osm_lines")
plot(st_geometry(highway$osm_polygons), main="osm_polygons")
```

The points or the lines datasets look must useful to us, there is nothing in the polygon layer. 

Let's use the lines element and add out camera stations:

```{r}
par(mfrow=c(1,1))
plot(st_as_sfc(aoi))     # st_as_sfc created a polygon from a `bbox` object
plot(st_geometry(highway$osm_lines), add=T)
plot(st_geometry(locs_sf), col="red", add=T)
```

We can now calculate the distances from our cameras to these objects using the following codes:

`st_nearest_feature` gives us the index number of the feature which is closest to each station. 

We can the use this to request the distance from that nearest feature to each camera station using `st_distance`. Which, put together, looks like:

```{r}
# Create an index of the nearest object in `highway$osm_lines` to locs_sf
index <- st_nearest_feature(locs_sf, highway$osm_lines)

# Use that index to ask for the distance to that object
locs_sf$road_dist_m <- st_distance(locs_sf, highway$osm_lines[index,], 
                                   by_element=T) # Note `by_element=T` tells st_distance to evaluate things line by line. 
```

#### water bodies

We also might want to calculate the distances to the nearest water body, and important resource for wildlife. We can do that using the following: 

```{r}
water <- opq(aoi) %>%
           add_osm_feature(key="water") %>%
           osmdata_sf()

```

Lets check our data:

```{r}
par(mfrow=c(1,3))
plot(st_geometry(water$osm_points), main="osm_points")
plot(st_geometry(water$osm_lines), main="osm_lines")
plot(st_geometry(water$osm_polygons), main="osm_polygons")
par(mfrow=c(1,1))
```

In this instance, the lines and the polygons are incomplete, out best bet is the points file!

```{r}
index <- st_nearest_feature(locs_sf, water$osm_points)

locs_sf$water_dist_m <- st_distance(locs_sf, water$osm_points[index,], by_element=T) # Note `by_element=T` tells st_distance to evaluate things line by line. 
```

For more examples of using the `osmdata` package see: [the projects github page](https://github.com/ropensci/osmdata)

### Google Earth Engine

Google Earth Engine is now available within the R environment using the incredible `rgee` package. Google Earth Engine is a game changer for accessing large freely available datasets, of the sort that might be used in data synthesis projects. The list of data sets you can access is here: [Google Earth Engine Catalogue](https://developers.google.com/earth-engine/datasets).

**Why use `rgee`?**
Becasue it allows you to access vast datasets stored in the clound, which you do not need to download on your computer! Its 
However, it can be tricky to set up - and well beyond the scope of this course! If you are feeling a little bit adventurous, you can follow the steps in this `rgee` vignette":

[Introduction to rgee](https://cran.r-project.org/web/packages/rgee/vignettes/rgee01.html)

This thread also helped me [gcloud issues](https://github.com/r-spatial/rgee/issues/269)

If you do manage to get it setup, it opens are world of possibilities!

Lets look at a `rgee` workflow for camera traps. First load the `rgee` package.

```{r}
library(rgee)
ee_Initialize()

```

Next let's check if python and R are communicating properly:

```{r, eval=F}
ee_check()
```

If they are - you should see something like this:

```{r}
knitr::include_graphics("images/analysis_covariates/rgee_check.PNG")
```


#### Discrete example

The way `rgee` works is you first need to call a data layer, for example the [100m global landcover dataset](https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_Landcover_100m_Proba-V-C3_Global#bands).


```{r}

#Land Cover
LC_dataset <- ee$Image("COPERNICUS/Landcover/100m/Proba-V-C3/Global/2019")$select('discrete_classification')

```

We can quickly plot the layer to see what it looks like before moving on:

```{r}

Map$setCenter(-88.6, 26.4, 1);
Map$addLayer(LC_dataset, {}, "Land Cover");

```

We can then extract the values of that layer to our camera locations using `ee_extract`:

```{r, message=F, warning=F}
habs <- ee_extract(LC_dataset, locs_sf)

# Read in the LCC key
codes <- read.csv("data/raw_data/example_covariates/LCC_codes.csv")

# Use left join to label the codes
habs <- left_join(habs, codes)

# And update the locs_sf dataframe
locs_sf$lcc_habitats <- habs$hab_code
```

Let's checkout the habitat designations:

```{r}
table(locs_sf$lcc_habitats)
```

Well that was very fast and very useful!

#### Continuous example

Let's repeat this process with a continuous variable like biomass. We will use the
[Global Aboveground and Belowground Biomass Carbon Density Maps](https://developers.google.com/earth-engine/datasets/catalog/NASA_ORNL_biomass_carbon_density_v1).

Lets read in the layer 

```{r}
biomass <- ee$ImageCollection("NASA/ORNL/biomass_carbon_density/v1");

# Specify the layer we want to plot
bio = biomass$first()

# Set up the colours for the visualisation
viz <- list(
  bands="agb",
  max = 129,
  min = 0,
  palette = c('#0c0c0c', '#071aff', '#ff0000', '#ffbd03', '#fbff05', '#fffdfd')
)

# Plot the map
Map$addLayer(eeObject = bio, visParams = viz)

```

Extract the data using `ee_extract`:

```{r}
tmp <- ee_extract(biomass, locs_sf)
locs_sf$biomass_agb <- tmp$X2010_agb
```

Make a plot to see the distribution of values.

#### Other layers of interest

Below we highlight other layers we have used in different analyses.

**Global Human Modification Index**

[Human Modification Index](https://developers.google.com/earth-engine/datasets/catalog/CSP_HM_GlobalHumanModification)

```{r}
hmi <- ee$ImageCollection("CSP/HM/GlobalHumanModification")

# select the first image of the collection which corresponds to the cumulative HM  
hm = hmi$first()
viz <- list(
  bands="gHM",
  max = 1,
  min = 0,
  palette = c('#0c0c0c', '#071aff', '#ff0000', '#ffbd03', '#fbff05', '#fffdfd')
)

Map$addLayer(eeObject = hm, visParams = viz)

```

**Protected area status**

[WDPA: World Database on Protected Areas](https://developers.google.com/earth-engine/datasets/catalog/WCMC_WDPA_current_polygons)

Note - you have to zoom in to see the polygons! 

```{r}
gpa  <- ee$FeatureCollection("WCMC/WDPA/current/polygons")
# Plot it (note you have to zoom in to see the data)
Map$addLayer(gpa, {}, "default display") 

```

As ever, these codes just scratch the surface of the power of Google Earth Engine. See the [rgee documentation](https://cran.r-project.org/web/packages/rgee/vignettes/rgee01.html) for more ideas!


### Time-varying covariates

#### MODISTools 

`MODIStools` is an R interface to the [MODIS Land Products Subsets](https://modis.ornl.gov/data/modis_webservice.html) web services. It allows for easy access to ‘MODIS’ time series directly to your computer! When using `MODIStools` you should reference: 

[Hufkens (2022). The MODISTools package: an interface to the MODIS Land Products Subsets Web Services](https://github.com/ropensci/MODISTools) 

Also click that link for more details on how to use it. 

Let's load the package:

```{r}
library(MODISTools)
```

For `MODIStools` to work, we need to provide a dataframe with the following columns:
- `site_name` - the placename
- `lat'
- 'long'

```{r}
modis_locs <- locs %>% 
  select("placename", "longitude", "latitude") %>% 
  rename(site_name=placename, lat=latitude, lon=longitude)
```

We can then look at the available bands for different products. 

Two commonly used ones are [MOD13Q1](https://lpdaac.usgs.gov/products/mod13q1v006/) for the derivation of NDVI/EVI, and [MOD15A2H](https://lpdaac.usgs.gov/products/mod15a2hv006/) for the derivation of leaf area index (LAI).

```{r}
# list available bands for a product
bands <- mt_bands(product = "MOD13Q1") #MOD15A2H
head(bands)
```

When we run `MODIStools` the underlying algorithm chooses the best available pixel value from all the acquisitions from the 16 day period. The criteria used is lowest cloud cover, lowest satellite view angle, and the highest NDVI/EVI value.

```{r}
# list available dates for a prodcut at a location
dates <- mt_dates(product = "MOD13Q1", lat = modis_locs$lat[1], lon = modis_locs$lon[1]) #MOD15A2H
head(dates);tail(dates)
```

In the interest of processing time, lets not pull the NDVI scores for the full date range. Instead, we will focus on mid summer in 2019. 

```{r}
algar_ndvi <- mt_batch_subset(product = "MOD13Q1",
                              df=modis_locs,
                              band = "250m_16_days_NDVI",
                              start = "2019-07-01",
                              end = "2019-08-31",
                              km_lr = 0,         # Use these options if you want to buffer the value (km left)
                              km_ab = 0,         # Use these options if you want to buffer the value (km above)
                              internal = TRUE)

```

The raw output is somewhat intimidating:

```{r}
algar_ndvi[1:10, ] %>% 
  kbl() %>% 
  scroll_box(height = "300px") %>%
  kable_paper("striped", full_width = F)
```

So lets simplify it to the key elements of information and rename them to match our camera data where approriate:

```{r}
ndvi_simple <- algar_ndvi %>% 
  select(	site, band, calendar_date, value) %>% 
  rename(placename=site)

ndvi_simple[1:10, ] %>% 
  kbl() %>% 
  scroll_box(height = "300px") %>%
  kable_paper("striped", full_width = F)

```

So we have multiple observations per site. Lets take an average and add it to our `locs_sf` dataframe.

```{r, message=F, warning=F}
tmp <- ndvi_simple %>%             #Take the NDVI layer
  group_by(placename) %>%          # Group observations by the placename
  summarize(mean_ndvi=mean(value)) # Take the mean of the values and call the new column `mean_ndvi`

# Add the new data to our locations dataframe
locs_sf <- left_join(locs_sf, tmp)

```

And check the output:
```{r}
boxplot(locs_sf$mean_ndvi,
        ylab="Mean NDVI score",
        las=1)
```


#### Following sites through time

Whilst it is interesting to compare average NDVI score between different sites, we might also want to use NDVI to control for changes in plant productivity with the seasons. It would take too long to do for this for all sites during this course, however we can do it for two different sites across one whole year (2017):

**NOTE - NOT CURRENTLY WORKING**

```{r, eval=F}
# Convert the dates
library(lubridate)

time_ndvi <- mt_batch_subset(product = "MOD13Q1",
                              df=modis_locs[c(1, 66),],          #Just ALG001 and ALG066
                              band = "250m_16_days_NDVI",
                              start = "2017-01-01",         # The first observation in out dataset
                              end = "2017-12-31",           # the last observation
                              km_lr = 0,
                              km_ab = 0,
                              internal = TRUE)

# Simplify the output

time_simple <- time_ndvi %>% 
  select(	site, band, calendar_date, value) %>% 
  rename(placename=site)

# Convert to date objects
time_simple$calendar_date <- ymd(time_simple$calendar_date)

```

Lets plot the NDVi through time for each.

```{r, eval=F}
library(plotly)
fig <- plot_ly(time_simple, x = ~calendar_date, y = ~value, name = time_simple$placename, type = 'scatter', mode = 'lines',split = ~placename) 
fig
```


### Digging deeper

If you want to dig into estimating NDVI metrics from camera trap viewshed, rather than from satellite data, check out the `phenopix` R package. It allows the user to extract visual information from time lapse images.  It provides a quantitative daily measure of vegetation phenology at each site (e.g. green-up, senescence, snow cover).

[Alberton, B. et al. 2017. Introducing digital cameras to monitor plant phenology in the tropics: applications for conservation. Perspect. Ecol. Conserv](https://www.sciencedirect.com/science/article/pii/S2530064417300019)

[Filippa, G. et al. 2017. phenopix: Process Digital Images of a Vegetation Cover. R package version 2.3.1.](https://rdrr.io/rforge/phenopix/)


The Phenopix package has a five step process:

1. a region of interest (ROI) is identified;
2. the red, green, and blue digital numbers from each image in the timeseries is extracted and an index of relative ‘greenness’ is computed and plotted from the digital numbers; 
3. the vegetation indices’ data points are filtered to remove inconsistencies; 
4. a curve is fit to the data and phenophases are determined from the curve; 
5. phenophase uncertainties are calculated.
  

To see an application and comparison of these metrics, we highly recommend that you check out Catherine Sun's (WildCo alumni) paper on the subject:

[Sun, Catherine, et al. "Simultaneous monitoring of vegetation dynamics and wildlife activity with camera traps to assess habitat change." Remote Sensing in Ecology and Conservation 7.4 (2021): 666-684.](https://zslpublications.onlinelibrary.wiley.com/doi/10.1002/rse2.222)


## Convert and save your covariates

```{r, message=F, warning=F}
# Convert columns to numeric
locs_sf$road_dist_m <- as.numeric(locs_sf$road_dist_m)

# Convert it back to a dataframe
locs_sf$geometry <- NULL

locs <- left_join(locs, locs_sf)


# Write the dataset

write.csv(locs, "AlgarRestorationProject_camera_locations_and_covariates.csv", row.names=F)

```


## Correlations between predictors 

So we have used a variety of different techniques to generate covariates for our subsequent analyses. However, it is important to note that we cannot just through these variables into a model.

One way to check if your different variables are confound/correlated is using the `corrplot` package.


```{r}
library(corrplot)

# First we need to create a correlation matrix between the different variables of interest
M <- cor(locs[, c("line_of_sight_m", "water_depth_m", "elevation",
                     "road_dist_m", "mean_ndvi")])
```

Now lets make the basic `corrplot`:

```{r}
corrplot(M)
```

The cells denote pairewaise correlations between the rows and the columns. The great thing about `corrplot` is customisation option are near endless - see [the corrplot vignette](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html).

Let's make a better, more informative, corrplot!

```{r}

corrplot(M,                              #The correlation matrix we made
         method="color",                 # How we want the cells 
         type="upper",                   # Just show the upper part (it is usually mirrored)
         order="hclust",                 # Order the variables using the hclust method
         addCoef.col = "black",          # Add coefficient of correlation  
         tl.col="black", tl.srt=45,      # Control the text label color and rotation
         diag=F                          # Supress the diagnal correlations (which are 1 anyway)
         )

```

In general there is very low correlation between our different predictors! If we were seeing parwise correlations >0.7 we perhaps wouldn't include those in the same model. 




